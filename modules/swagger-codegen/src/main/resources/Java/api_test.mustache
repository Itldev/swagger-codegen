{{>licenseInfo}}

package {{package}};

import {{invokerPackage}}.ApiException;
{{#imports}}import {{import}};
{{/imports}}
import org.junit.Test;

{{^fullJavaUtil}}
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
{{/fullJavaUtil}}

{{#spring}}
import org.junit.runner.RunWith;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.TestExecutionListeners;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;
import org.springframework.test.context.support.AnnotationConfigContextLoader;
import org.springframework.test.context.support.DependencyInjectionTestExecutionListener;
{{/spring}}

/**
 * API tests for {{classname}}
 */
{{#spring}}
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(loader = AnnotationConfigContextLoader.class)
@TestExecutionListeners(DependencyInjectionTestExecutionListener.class)
@ComponentScan(basePackages = "{{invokerPackage}}")
{{/spring}}
public class {{classname}}Test {
    {{#spring}}
    @Autowired
    {{/spring}}
    private {{^spring}}final {{/spring}}{{classname}} api{{^spring}} = new {{classname}}(){{/spring}};

    {{#operations}}{{#operation}}
    /**
     * {{summary}}
     *
     * {{notes}}
     *
     * @throws ApiException
     *          if the Api call fails
     */
    @Test
    public void {{operationId}}Test() throws ApiException {
        {{#allParams}}
        {{{dataType}}} {{paramName}} = null;
        {{/allParams}}
        // {{#returnType}}{{{returnType}}} response = {{/returnType}}api.{{operationId}}({{#allParams}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}});

        // TODO: test validations
    }
    {{/operation}}{{/operations}}
}
